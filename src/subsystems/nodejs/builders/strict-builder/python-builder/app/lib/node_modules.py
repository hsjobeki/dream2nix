import os
import shutil
from pathlib import Path
from typing import Any, Optional, TypedDict

import json

from .config import root
from .dependencies import Dependency, DepsTree, get_all_deps, recurse_deps_tree
from .logger import logger
from .derivation import InstallMethod, get_install_method, get_self
from .package import (
    NodeModulesPackage,
    NodeModulesTree,
    create_binary,
    get_all_deps_tree,
    get_bins,
    get_node_modules_tree,
    get_package_json,
)


def _create_package_from_derivation(
    dep: Dependency,
    path: Path,
):
    node_modules = root / path
    target = node_modules / Path(dep.name)
    bin_dir = node_modules / Path(".bin")
    logger.info(
        f"""create package from derivation
while building node_modules for {get_self()}
{str(dep)}
from: {dep.derivation}
install target: {target}

    """
    )

    target.parent.mkdir(parents=True, exist_ok=True)
    install_method = get_install_method()

    if not get_package_json(Path(dep.derivation)):
        logger.debug(f"{str(dep)} is not a package. Skipping installation")
        return
    # check if there is already the right package installed
    # folder might be created, but package.json only when installed
    if not (target / Path("package.json")).exists():
        if install_method == InstallMethod.copy:
            target.mkdir(parents=True, exist_ok=True)
            # print(f"copy from {dep.derivation} to {target}")
            # let 'cp -r' handle the merge logic in case node_modules folder already exist.
            # this is more performant and has less complexity than merging recursive in python
            os.system(f"cp -r {dep.derivation} {target}")
            os.system(f"chmod -R +rw {target}")

        elif install_method == InstallMethod.symlink:
            target.mkdir(parents=True, exist_ok=True)
            print(f"linking {target} -> {dep.derivation}")
            for entry in os.listdir(dep.derivation):
                if not (target / Path(entry)).exists():
                    (target / Path(entry)).symlink_to(dep.derivation / Path(entry))
                else:
                    logger.info(
                        f"skipping: file {(target / Path(entry))} already exists."
                    )

        binaries = get_bins(dep)
        for name, rel_path in binaries.items():
            create_binary(bin_dir / Path(name), Path(dep.name) / rel_path)


class Passthrough(TypedDict):
    """
    Wrapper class
    Holds global information during recursion in <_make_folders_rec>
    """

    all_deps: dict[str, Dependency]
    flat_deps: list[str]


def _make_folders_rec(
    node_modules_tree: NodeModulesTree,
    passthrough: Passthrough,
    path: Path = Path(""),
):
    """
    Builds the node_modules folder structure
    from the NodeModulesTree datastructures
    """
    name: str
    meta: NodeModulesPackage

    for name, meta in node_modules_tree.items():

        version = meta["version"]
        dependencies: Optional[NodeModulesTree] = meta.get("dependencies", None)
        found_dependency = passthrough["all_deps"].get(f"{name}@{version}")

        if found_dependency:
            source = found_dependency.derivation
            dep = Dependency(
                name,
                version,
                source,
                dependencies=dependencies,
            )

            if dependencies:
                _make_folders_rec(
                    node_modules_tree=dependencies,
                    passthrough=passthrough,
                    path=path / Path(f"{name}/node_modules"),
                )

            _create_package_from_derivation(
                dep,
                path,
            )
        else:

            if f"{name}@{version}" in passthrough["flat_deps"]:
                logger.critical(f"{name}@{version} required but not found")


def create_node_modules():
    def collect_dependency(
        accumulator: Any, dep: Dependency, dep_tree: Optional[DepsTree]
    ) -> Any:
        identifier = str(dep)
        if identifier not in accumulator.keys():
            accumulator[identifier] = dep
        return accumulator

    # pre-calculated node modules tree structure from nix evaluation time
    nm_tree = get_node_modules_tree()
    # all dependencies of the current package
    all_deps = get_all_deps_tree()

    collected: dict[str, Dependency] = recurse_deps_tree(
        all_deps, collect_dependency, accumulator={}
    )

    printable = {key: str(value) for (key, value) in collected.items()}
    root_pkg = get_self()
    flat_deps: list[str] = get_all_deps(all_deps, root_pkg.name, root_pkg.version)

    logger.warning(
        f"""
        building node modules of {root_pkg}
        collected {printable}
        flat_deps {flat_deps}
        nm_tree {json.dumps(nm_tree)}
    """
    )

    _make_folders_rec(
        nm_tree,
        passthrough={"all_deps": collected, "flat_deps": flat_deps},
    )
